<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>AUTh-ARL Core Stack: arl::math Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">AUTh-ARL Core Stack
   &#160;<span id="projectnumber">0.6.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacearl.html">arl</a></li><li class="navelem"><a class="el" href="namespacearl_1_1math.html">math</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">arl::math Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The namespace having code related to math calculations and tools.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacearl_1_1math_1_1filter"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearl_1_1math_1_1filter.html">filter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarl_1_1math_1_1_admittance.html">Admittance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrates the dynamical system for admittance control.  <a href="classarl_1_1math_1_1_admittance.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarl_1_1math_1_1_pose.html">Pose</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a pose in 3D space, i.e. a point of the SE(3) space.  <a href="classarl_1_1math_1_1_pose.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarl_1_1math_1_1_clik.html">Clik</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates joint velocities given desired task velocities by implementing Closed Loop Inverse Kinematics.  <a href="classarl_1_1math_1_1_clik.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarl_1_1math_1_1_mvn.html">Mvn</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a Multivariate Normal Distribution. It provides functionalities like getting its PDF or generating random vectors from this distribution.  <a href="classarl_1_1math_1_1_mvn.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aff8f579b84214c8c721f5855d9bd842b"><td class="memItemLeft" align="right" valign="top">arma::mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearl_1_1math.html#aff8f579b84214c8c721f5855d9bd842b">getLineSegment</a> (const arma::vec &amp;p1, const arma::vec &amp;p2, double dlambda)</td></tr>
<tr class="memdesc:aff8f579b84214c8c721f5855d9bd842b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a discrete line segments between two points in the N-dimensional space. The function assumes that the two given points are of the same dimension.  <a href="#aff8f579b84214c8c721f5855d9bd842b">More...</a><br/></td></tr>
<tr class="separator:aff8f579b84214c8c721f5855d9bd842b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f589da00ff3faae1fb99cadb90878a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearl_1_1math.html#a22f589da00ff3faae1fb99cadb90878a">areCoplanar</a> (const std::vector&lt; KDL::Vector &gt; &amp;point, double epsilon=1e-6)</td></tr>
<tr class="memdesc:a22f589da00ff3faae1fb99cadb90878a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a set of 3D points are cooplannar.  <a href="#a22f589da00ff3faae1fb99cadb90878a">More...</a><br/></td></tr>
<tr class="separator:a22f589da00ff3faae1fb99cadb90878a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c224d7506d71f09c7c32f87a8df284"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearl_1_1math.html#aa2c224d7506d71f09c7c32f87a8df284">sortCircularOrder</a> (const std::vector&lt; KDL::Vector &gt; &amp;input, std::vector&lt; KDL::Vector &gt; *output)</td></tr>
<tr class="memdesc:aa2c224d7506d71f09c7c32f87a8df284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts a set of unsorted points in circular ordering.  <a href="#aa2c224d7506d71f09c7c32f87a8df284">More...</a><br/></td></tr>
<tr class="separator:aa2c224d7506d71f09c7c32f87a8df284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46c677184599a9862485e4f4f654d1a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearl_1_1math.html#af46c677184599a9862485e4f4f654d1a">isWithinPolygon</a> (const arma::vec &amp;point, const arma::mat &amp;polygon)</td></tr>
<tr class="memdesc:af46c677184599a9862485e4f4f654d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a point lies within a polygon.  <a href="#af46c677184599a9862485e4f4f654d1a">More...</a><br/></td></tr>
<tr class="separator:af46c677184599a9862485e4f4f654d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a846280f7c2de8511d59de2770fb3b26e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearl_1_1math.html#a846280f7c2de8511d59de2770fb3b26e">getTranslationalManipulabilityMeasureStrongSense</a> (const arma::mat &amp;jac)</td></tr>
<tr class="memdesc:a846280f7c2de8511d59de2770fb3b26e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the translational manipulability measure in the strong sense as this is defined in Yoshikawa, Tsuneo. "Translational and rotational
manipulability of robotic manipulators." American Control Conference, 1990. IEEE, 1990. APA.  <a href="#a846280f7c2de8511d59de2770fb3b26e">More...</a><br/></td></tr>
<tr class="separator:a846280f7c2de8511d59de2770fb3b26e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4736fd583db4e67f2cbdce900c9404b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearl_1_1math.html#ab4736fd583db4e67f2cbdce900c9404b">getTranslationalManipulabilityMeasureStrongSense</a> (const arma::mat &amp;jac, const arma::mat &amp;choose)</td></tr>
<tr class="memdesc:ab4736fd583db4e67f2cbdce900c9404b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the translational manipulability measure in the strong sense as this is defined in Yoshikawa, Tsuneo. "Translational and rotational
manipulability of robotic manipulators." American Control Conference, 1990. IEEE, 1990. APA.  <a href="#ab4736fd583db4e67f2cbdce900c9404b">More...</a><br/></td></tr>
<tr class="separator:ab4736fd583db4e67f2cbdce900c9404b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae021640b03fe691e7f8f92b8c3cd406e"><td class="memItemLeft" align="right" valign="top">arma::vec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearl_1_1math.html#ae021640b03fe691e7f8f92b8c3cd406e">getOrientationError</a> (const arma::vec &amp;q, const arma::vec &amp;qd)</td></tr>
<tr class="memdesc:ae021640b03fe691e7f8f92b8c3cd406e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the orientation error between two quaternions using Armadillo.  <a href="#ae021640b03fe691e7f8f92b8c3cd406e">More...</a><br/></td></tr>
<tr class="separator:ae021640b03fe691e7f8f92b8c3cd406e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b06eb9b8f30a410d7788815053f6bd6"><td class="memItemLeft" align="right" valign="top">KDL::Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearl_1_1math.html#a2b06eb9b8f30a410d7788815053f6bd6">getOrientationError</a> (const std::vector&lt; double &gt; &amp;quat, const std::vector&lt; double &gt; &amp;quat_d)</td></tr>
<tr class="memdesc:a2b06eb9b8f30a410d7788815053f6bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the orientation error between two quaternions using STL and KDL.  <a href="#a2b06eb9b8f30a410d7788815053f6bd6">More...</a><br/></td></tr>
<tr class="separator:a2b06eb9b8f30a410d7788815053f6bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a042963eb885eb538bc39572416675617"><td class="memItemLeft" align="right" valign="top">arma::mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearl_1_1math.html#a042963eb885eb538bc39572416675617">quatToRot</a> (const arma::vec &amp;q)</td></tr>
<tr class="memdesc:a042963eb885eb538bc39572416675617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a quaternion to a rotation matrix.  <a href="#a042963eb885eb538bc39572416675617">More...</a><br/></td></tr>
<tr class="separator:a042963eb885eb538bc39572416675617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4e0874e1c1504bdcb4e9726ff77ba1"><td class="memItemLeft" align="right" valign="top">arma::vec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearl_1_1math.html#abb4e0874e1c1504bdcb4e9726ff77ba1">rotToQuat</a> (const arma::mat &amp;R)</td></tr>
<tr class="memdesc:abb4e0874e1c1504bdcb4e9726ff77ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a rotation matrix to a quaternion.  <a href="#abb4e0874e1c1504bdcb4e9726ff77ba1">More...</a><br/></td></tr>
<tr class="separator:abb4e0874e1c1504bdcb4e9726ff77ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9066e6f4d23a4ce1696e50c61b51b6d"><td class="memItemLeft" align="right" valign="top">arma::vec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearl_1_1math.html#ad9066e6f4d23a4ce1696e50c61b51b6d">getQuatConjugate</a> (const arma::vec &amp;q)</td></tr>
<tr class="memdesc:ad9066e6f4d23a4ce1696e50c61b51b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the quaternion conjugate.  <a href="#ad9066e6f4d23a4ce1696e50c61b51b6d">More...</a><br/></td></tr>
<tr class="separator:ad9066e6f4d23a4ce1696e50c61b51b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274ebcb6b8e84f6afd2bc073635a5f5e"><td class="memItemLeft" align="right" valign="top">arma::vec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearl_1_1math.html#a274ebcb6b8e84f6afd2bc073635a5f5e">getQuatInverse</a> (const arma::vec &amp;q)</td></tr>
<tr class="memdesc:a274ebcb6b8e84f6afd2bc073635a5f5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the inverse of a given quaternion.  <a href="#a274ebcb6b8e84f6afd2bc073635a5f5e">More...</a><br/></td></tr>
<tr class="separator:a274ebcb6b8e84f6afd2bc073635a5f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4569b9300cd46df7b8573b39c99722"><td class="memItemLeft" align="right" valign="top">arma::vec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearl_1_1math.html#afc4569b9300cd46df7b8573b39c99722">getQuatProduct</a> (const arma::vec &amp;q1, const arma::vec &amp;q2)</td></tr>
<tr class="memdesc:afc4569b9300cd46df7b8573b39c99722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the product of two quaternions.  <a href="#afc4569b9300cd46df7b8573b39c99722">More...</a><br/></td></tr>
<tr class="separator:afc4569b9300cd46df7b8573b39c99722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9659ff4893af2cbbc4e957675fcc6be2"><td class="memItemLeft" align="right" valign="top">arma::vec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearl_1_1math.html#a9659ff4893af2cbbc4e957675fcc6be2">getQuatDifference</a> (const arma::vec &amp;q, const arma::vec &amp;qd)</td></tr>
<tr class="memdesc:a9659ff4893af2cbbc4e957675fcc6be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the difference of two quaternions.  <a href="#a9659ff4893af2cbbc4e957675fcc6be2">More...</a><br/></td></tr>
<tr class="separator:a9659ff4893af2cbbc4e957675fcc6be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe94ac3c6543ab4127acdb0a751d6ca8"><td class="memItemLeft" align="right" valign="top">arma::vec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearl_1_1math.html#afe94ac3c6543ab4127acdb0a751d6ca8">rotateQuat</a> (const arma::vec &amp;w, const arma::vec &amp;q)</td></tr>
<tr class="memdesc:afe94ac3c6543ab4127acdb0a751d6ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrates the orientation in quaternion.  <a href="#afe94ac3c6543ab4127acdb0a751d6ca8">More...</a><br/></td></tr>
<tr class="separator:afe94ac3c6543ab4127acdb0a751d6ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5cbf84c1794b164c19e27aa2bb884b3"><td class="memItemLeft" align="right" valign="top">arma::vec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearl_1_1math.html#ae5cbf84c1794b164c19e27aa2bb884b3">getQuatExp</a> (const arma::vec &amp;w)</td></tr>
<tr class="separator:ae5cbf84c1794b164c19e27aa2bb884b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a59063e37593699cc183c9f8c26df2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearl_1_1math.html#a77a59063e37593699cc183c9f8c26df2">rotationHasUnitColumns</a> (const KDL::Rotation &amp;rot, double eps=1e-8)</td></tr>
<tr class="memdesc:a77a59063e37593699cc183c9f8c26df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if the columns of the rotation matrix are unit vectors.  <a href="#a77a59063e37593699cc183c9f8c26df2">More...</a><br/></td></tr>
<tr class="separator:a77a59063e37593699cc183c9f8c26df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252cc50703eed077544ff8ac0037249e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearl_1_1math.html#a252cc50703eed077544ff8ac0037249e">rotationHasOrthogonalColumns</a> (const KDL::Rotation &amp;rot, double eps=1e-8)</td></tr>
<tr class="memdesc:a252cc50703eed077544ff8ac0037249e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if the columns of the rotation matrix are orthogonal.  <a href="#a252cc50703eed077544ff8ac0037249e">More...</a><br/></td></tr>
<tr class="separator:a252cc50703eed077544ff8ac0037249e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41abc64cb803f25aadfcf18a721a25a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearl_1_1math.html#a41abc64cb803f25aadfcf18a721a25a9">rotationIsRightHanded</a> (const KDL::Rotation &amp;rot, double eps=1e-8)</td></tr>
<tr class="memdesc:a41abc64cb803f25aadfcf18a721a25a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if the columns of the rotation matrix form a right handed system.  <a href="#a41abc64cb803f25aadfcf18a721a25a9">More...</a><br/></td></tr>
<tr class="separator:a41abc64cb803f25aadfcf18a721a25a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0cfd040f73a0df410290867490c902"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearl_1_1math.html#a9d0cfd040f73a0df410290867490c902">rotationIsOk</a> (const KDL::Rotation &amp;rot, double eps=1e-8)</td></tr>
<tr class="memdesc:a9d0cfd040f73a0df410290867490c902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if a 3x3 matrix R is a legit rotation matrix, i.e. if R belongs to SO(3).  <a href="#a9d0cfd040f73a0df410290867490c902">More...</a><br/></td></tr>
<tr class="separator:a9d0cfd040f73a0df410290867490c902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b85c052a9aa6c8e770fe5001ce91b5"><td class="memItemLeft" align="right" valign="top">arma::mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearl_1_1math.html#a83b85c052a9aa6c8e770fe5001ce91b5">rotX</a> (double theta)</td></tr>
<tr class="memdesc:a83b85c052a9aa6c8e770fe5001ce91b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the basic rotation around the X-axis.  <a href="#a83b85c052a9aa6c8e770fe5001ce91b5">More...</a><br/></td></tr>
<tr class="separator:a83b85c052a9aa6c8e770fe5001ce91b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4d1be15ff669441d38022971aab717"><td class="memItemLeft" align="right" valign="top">arma::mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearl_1_1math.html#a7f4d1be15ff669441d38022971aab717">rotY</a> (double theta)</td></tr>
<tr class="memdesc:a7f4d1be15ff669441d38022971aab717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the basic rotation around the Y-axis.  <a href="#a7f4d1be15ff669441d38022971aab717">More...</a><br/></td></tr>
<tr class="separator:a7f4d1be15ff669441d38022971aab717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e642eb6a8a7576d87f7aab5bacd037"><td class="memItemLeft" align="right" valign="top">arma::mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearl_1_1math.html#af8e642eb6a8a7576d87f7aab5bacd037">rotZ</a> (double theta)</td></tr>
<tr class="memdesc:af8e642eb6a8a7576d87f7aab5bacd037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the basic rotation around the Z-axis.  <a href="#af8e642eb6a8a7576d87f7aab5bacd037">More...</a><br/></td></tr>
<tr class="separator:af8e642eb6a8a7576d87f7aab5bacd037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae096bdbbfbaaa79d825b9a8efa0d962c"><td class="memItemLeft" align="right" valign="top">arma::mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearl_1_1math.html#ae096bdbbfbaaa79d825b9a8efa0d962c">getScrewTransformation</a> (const arma::mat &amp;homogen)</td></tr>
<tr class="memdesc:ae096bdbbfbaaa79d825b9a8efa0d962c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the screw transformation.  <a href="#ae096bdbbfbaaa79d825b9a8efa0d962c">More...</a><br/></td></tr>
<tr class="separator:ae096bdbbfbaaa79d825b9a8efa0d962c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a337df1569bc80573a59551a146d4fa1e"><td class="memItemLeft" align="right" valign="top">arma::mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearl_1_1math.html#a337df1569bc80573a59551a146d4fa1e">get6x6Rotation</a> (const arma::mat &amp;rotation)</td></tr>
<tr class="memdesc:a337df1569bc80573a59551a146d4fa1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 6x6 matrix which the upper left and the down right sumbmatrices are the given 3x3 rotation matrix.  <a href="#a337df1569bc80573a59551a146d4fa1e">More...</a><br/></td></tr>
<tr class="separator:a337df1569bc80573a59551a146d4fa1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109b0f45c469d8ae2179048a0882a9c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearl_1_1math.html#a109b0f45c469d8ae2179048a0882a9c3">skewSymmetric</a> (const KDL::Vector &amp;v, KDL::Rotation *skew)</td></tr>
<tr class="memdesc:a109b0f45c469d8ae2179048a0882a9c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the skew symmetrix given a 3D vector using KDL.  <a href="#a109b0f45c469d8ae2179048a0882a9c3">More...</a><br/></td></tr>
<tr class="separator:a109b0f45c469d8ae2179048a0882a9c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ffb383ccb1505823894d6d952187f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearl_1_1math.html#ac9ffb383ccb1505823894d6d952187f4">skewSymmetric</a> (const <a class="el" href="group___eigen_plugins.html#gaf4eeda183343d8ca1deabd41e881c31e">Eigen::Matrix</a>&lt; double, 3, 1 &gt; &amp;v, <a class="el" href="group___eigen_plugins.html#gaf4eeda183343d8ca1deabd41e881c31e">Eigen::Matrix</a>&lt; double, 3, 3 &gt; *skew)</td></tr>
<tr class="memdesc:ac9ffb383ccb1505823894d6d952187f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the skew symmetrix given a 3D vector using Eigen.  <a href="#ac9ffb383ccb1505823894d6d952187f4">More...</a><br/></td></tr>
<tr class="separator:ac9ffb383ccb1505823894d6d952187f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5efda35e2e9fbcf3edb1b60287a7965e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearl_1_1math.html#a5efda35e2e9fbcf3edb1b60287a7965e">skewSymmetric</a> (const arma::vec &amp;v, arma::mat *skew)</td></tr>
<tr class="memdesc:a5efda35e2e9fbcf3edb1b60287a7965e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the skew symmetrix given a 3D vector using Armadillo.  <a href="#a5efda35e2e9fbcf3edb1b60287a7965e">More...</a><br/></td></tr>
<tr class="separator:a5efda35e2e9fbcf3edb1b60287a7965e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b949c6e7ca3b3c2684425fa670d5a0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearl_1_1math.html#a94b949c6e7ca3b3c2684425fa670d5a0">qd_prev_</a> ({1, 0, 0, 0})</td></tr>
<tr class="separator:a94b949c6e7ca3b3c2684425fa670d5a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8481a19747b496668529660de78cef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearl_1_1math.html#a6f8481a19747b496668529660de78cef">singularity_avoid_</a> (singularity_avoid)</td></tr>
<tr class="separator:a6f8481a19747b496668529660de78cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1eab115040e0a0e335d93e6b865e48"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearl_1_1math.html#aec1eab115040e0a0e335d93e6b865e48">pinv_method_</a> (pinv_method)</td></tr>
<tr class="separator:aec1eab115040e0a0e335d93e6b865e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37104fa2173c7e9aba835951aaea28c5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearl_1_1math.html#a37104fa2173c7e9aba835951aaea28c5">getTranslationalManipulabilityMeasureStrongSense</a> (const mat &amp;jac)</td></tr>
<tr class="separator:a37104fa2173c7e9aba835951aaea28c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a0e9d3644bf5720dfc8c5f85a393b9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearl_1_1math.html#a06a0e9d3644bf5720dfc8c5f85a393b9">getTranslationalManipulabilityMeasureStrongSense</a> (const mat &amp;jac, const mat &amp;choose)</td></tr>
<tr class="separator:a06a0e9d3644bf5720dfc8c5f85a393b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The namespace having code related to math calculations and tools. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a22f589da00ff3faae1fb99cadb90878a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool arl::math::areCoplanar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; KDL::Vector &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>1e-6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a set of 3D points are cooplannar. </p>
<p>Epsilon = 0 means zero tolerance to errors. Epsilon = 1 means that an arbitrary number of points will be considered as coplanar.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>The set of points to be tested </td></tr>
    <tr><td class="paramname">epsilon</td><td>A param which determines the error tolerance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if they are coplaner. False otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a337df1569bc80573a59551a146d4fa1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arma::mat arl::math::get6x6Rotation </td>
          <td>(</td>
          <td class="paramtype">const arma::mat &amp;&#160;</td>
          <td class="paramname"><em>rotation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 6x6 matrix which the upper left and the down right sumbmatrices are the given 3x3 rotation matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rotation</td><td>The given rotation matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 6x6 rotation matrix </dd></dl>

</div>
</div>
<a class="anchor" id="aff8f579b84214c8c721f5855d9bd842b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arma::mat arl::math::getLineSegment </td>
          <td>(</td>
          <td class="paramtype">const arma::vec &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arma::vec &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dlambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a discrete line segments between two points in the N-dimensional space. The function assumes that the two given points are of the same dimension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>The first N-dimensional point (start of line segment) </td></tr>
    <tr><td class="paramname">p2</td><td>The second N-dimensional point (end of line segment) </td></tr>
    <tr><td class="paramname">dlambda</td><td>The step for the discritization of the line segment</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A MxN matrix with M points of the line segment of N dimension. </dd></dl>

</div>
</div>
<a class="anchor" id="ae021640b03fe691e7f8f92b8c3cd406e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arma::vec arl::math::getOrientationError </td>
          <td>(</td>
          <td class="paramtype">const arma::vec &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arma::vec &amp;&#160;</td>
          <td class="paramname"><em>qd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the orientation error between two quaternions using Armadillo. </p>
<p>The quaternions are following the convention w, x, y, z. The returned quaternion error is given by Eq. 3.91 at p. 140 of book "Robotics: Modelling,
Planning and Control of Siciliano", with different sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The current orientation </td></tr>
    <tr><td class="paramname">qd</td><td>The desired orientation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The quaternion error</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespacearl_1_1math.html#ae021640b03fe691e7f8f92b8c3cd406e" title="Returns the orientation error between two quaternions using Armadillo. ">getOrientationError</a>(const std::vector&lt;double&gt;&amp; quat, const std::vector&lt;double&gt;&amp; quat_d); </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacearl_1_1math_ae021640b03fe691e7f8f92b8c3cd406e_cgraph.png" border="0" usemap="#namespacearl_1_1math_ae021640b03fe691e7f8f92b8c3cd406e_cgraph" alt=""/></div>
<map name="namespacearl_1_1math_ae021640b03fe691e7f8f92b8c3cd406e_cgraph" id="namespacearl_1_1math_ae021640b03fe691e7f8f92b8c3cd406e_cgraph">
<area shape="rect" id="node2" href="namespacearl_1_1math.html#a109b0f45c469d8ae2179048a0882a9c3" title="Calculates the skew symmetrix given a 3D vector using KDL. " alt="" coords="217,12,391,39"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a2b06eb9b8f30a410d7788815053f6bd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KDL::Vector arl::math::getOrientationError </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>quat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>quat_d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the orientation error between two quaternions using STL and KDL. </p>
<p>The quaternions are following the convention w, x, y, z. The returned quaternion error is given by Eq. 3.91 at p. 140 of book "Robotics: Modelling,
Planning and Control of Siciliano", with different sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quat</td><td>The current orientation </td></tr>
    <tr><td class="paramname">quat_d</td><td>The desired orientation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The quaternion error as a KDL Vector</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespacearl_1_1math.html#ae021640b03fe691e7f8f92b8c3cd406e" title="Returns the orientation error between two quaternions using Armadillo. ">getOrientationError(const arma::vec&amp; q, const arma::vec&amp; qd)</a> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacearl_1_1math_a2b06eb9b8f30a410d7788815053f6bd6_cgraph.png" border="0" usemap="#namespacearl_1_1math_a2b06eb9b8f30a410d7788815053f6bd6_cgraph" alt=""/></div>
<map name="namespacearl_1_1math_a2b06eb9b8f30a410d7788815053f6bd6_cgraph" id="namespacearl_1_1math_a2b06eb9b8f30a410d7788815053f6bd6_cgraph">
<area shape="rect" id="node2" href="namespacearl_1_1math.html#a109b0f45c469d8ae2179048a0882a9c3" title="Calculates the skew symmetrix given a 3D vector using KDL. " alt="" coords="217,12,391,39"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ad9066e6f4d23a4ce1696e50c61b51b6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arma::vec arl::math::getQuatConjugate </td>
          <td>(</td>
          <td class="paramtype">const arma::vec &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the quaternion conjugate. </p>
<p>The quaternions as input and output follows the convention w, x, y, z</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The given quaternion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The quaternion conjugate </dd></dl>

</div>
</div>
<a class="anchor" id="a9659ff4893af2cbbc4e957675fcc6be2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arma::vec arl::math::getQuatDifference </td>
          <td>(</td>
          <td class="paramtype">const arma::vec &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arma::vec &amp;&#160;</td>
          <td class="paramname"><em>qd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the difference of two quaternions. </p>
<p>The quaternions as input and output follows the convention w, x, y, z</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Quaternion input 1 </td></tr>
    <tr><td class="paramname">qd</td><td>Quaternion input 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Quaternion difference </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacearl_1_1math_a9659ff4893af2cbbc4e957675fcc6be2_cgraph.png" border="0" usemap="#namespacearl_1_1math_a9659ff4893af2cbbc4e957675fcc6be2_cgraph" alt=""/></div>
<map name="namespacearl_1_1math_a9659ff4893af2cbbc4e957675fcc6be2_cgraph" id="namespacearl_1_1math_a9659ff4893af2cbbc4e957675fcc6be2_cgraph">
<area shape="rect" id="node2" href="namespacearl_1_1math.html#afc4569b9300cd46df7b8573b39c99722" title="Calculates the product of two quaternions. " alt="" coords="241,5,413,32"/><area shape="rect" id="node4" href="namespacearl_1_1math.html#a274ebcb6b8e84f6afd2bc073635a5f5e" title="Calculates the inverse of a given quaternion. " alt="" coords="241,56,412,83"/><area shape="rect" id="node3" href="namespacearl_1_1math.html#a109b0f45c469d8ae2179048a0882a9c3" title="Calculates the skew symmetrix given a 3D vector using KDL. " alt="" coords="467,5,642,32"/><area shape="rect" id="node5" href="namespacearl_1_1math.html#ad9066e6f4d23a4ce1696e50c61b51b6d" title="Calculates the quaternion conjugate. " alt="" coords="461,56,648,83"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ae5cbf84c1794b164c19e27aa2bb884b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arma::vec arl::math::getQuatExp </td>
          <td>(</td>
          <td class="paramtype">const arma::vec &amp;&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a274ebcb6b8e84f6afd2bc073635a5f5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arma::vec arl::math::getQuatInverse </td>
          <td>(</td>
          <td class="paramtype">const arma::vec &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the inverse of a given quaternion. </p>
<p>The quaternions as input and output follows the convention w, x, y, z</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The given quaternion </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse of the quaternion </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacearl_1_1math_a274ebcb6b8e84f6afd2bc073635a5f5e_cgraph.png" border="0" usemap="#namespacearl_1_1math_a274ebcb6b8e84f6afd2bc073635a5f5e_cgraph" alt=""/></div>
<map name="namespacearl_1_1math_a274ebcb6b8e84f6afd2bc073635a5f5e_cgraph" id="namespacearl_1_1math_a274ebcb6b8e84f6afd2bc073635a5f5e_cgraph">
<area shape="rect" id="node2" href="namespacearl_1_1math.html#ad9066e6f4d23a4ce1696e50c61b51b6d" title="Calculates the quaternion conjugate. " alt="" coords="224,5,411,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="afc4569b9300cd46df7b8573b39c99722"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arma::vec arl::math::getQuatProduct </td>
          <td>(</td>
          <td class="paramtype">const arma::vec &amp;&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arma::vec &amp;&#160;</td>
          <td class="paramname"><em>q2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the product of two quaternions. </p>
<p>The quaternions as input and output follows the convention w, x, y, z</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q1</td><td>Quaternion input 1 </td></tr>
    <tr><td class="paramname">q1</td><td>Quaternion input 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The quaternion product </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacearl_1_1math_afc4569b9300cd46df7b8573b39c99722_cgraph.png" border="0" usemap="#namespacearl_1_1math_afc4569b9300cd46df7b8573b39c99722_cgraph" alt=""/></div>
<map name="namespacearl_1_1math_afc4569b9300cd46df7b8573b39c99722_cgraph" id="namespacearl_1_1math_afc4569b9300cd46df7b8573b39c99722_cgraph">
<area shape="rect" id="node2" href="namespacearl_1_1math.html#a109b0f45c469d8ae2179048a0882a9c3" title="Calculates the skew symmetrix given a 3D vector using KDL. " alt="" coords="227,5,402,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ae096bdbbfbaaa79d825b9a8efa0d962c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arma::mat arl::math::getScrewTransformation </td>
          <td>(</td>
          <td class="paramtype">const arma::mat &amp;&#160;</td>
          <td class="paramname"><em>homogen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the screw transformation. </p>
<p>The screw transformation (gamma matrix) for transforming a wrench applied on frame {B} and expressed in frame {B} to the wrench applied on frame {A} and expressed in frame {A}, as given in given by 4.27 in Doulgeri Robotics. The calculation is based on a 3x4 matrix storing the homogeneous transformation from tranferring something expressed in frame {B} to something expressed in frame {A}. The first three columns should contain the rotation matrix and the last column the translation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">homogen</td><td>The homogeneous transformation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The screw transformation matrix </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacearl_1_1math_ae096bdbbfbaaa79d825b9a8efa0d962c_cgraph.png" border="0" usemap="#namespacearl_1_1math_ae096bdbbfbaaa79d825b9a8efa0d962c_cgraph" alt=""/></div>
<map name="namespacearl_1_1math_ae096bdbbfbaaa79d825b9a8efa0d962c_cgraph" id="namespacearl_1_1math_ae096bdbbfbaaa79d825b9a8efa0d962c_cgraph">
<area shape="rect" id="node2" href="namespacearl_1_1math.html#a109b0f45c469d8ae2179048a0882a9c3" title="Calculates the skew symmetrix given a 3D vector using KDL. " alt="" coords="278,5,453,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a37104fa2173c7e9aba835951aaea28c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double arl::math::getTranslationalManipulabilityMeasureStrongSense </td>
          <td>(</td>
          <td class="paramtype">const mat &amp;&#160;</td>
          <td class="paramname"><em>jac</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacearl_1_1math_a37104fa2173c7e9aba835951aaea28c5_cgraph.png" border="0" usemap="#namespacearl_1_1math_a37104fa2173c7e9aba835951aaea28c5_cgraph" alt=""/></div>
<map name="namespacearl_1_1math_a37104fa2173c7e9aba835951aaea28c5_cgraph" id="namespacearl_1_1math_a37104fa2173c7e9aba835951aaea28c5_cgraph">
<area shape="rect" id="node2" href="namespacearl_1_1math.html#a846280f7c2de8511d59de2770fb3b26e" title="Calculates the translational manipulability measure in the strong sense as this is defined in Yoshika..." alt="" coords="280,5,507,46"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a846280f7c2de8511d59de2770fb3b26e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double arl::math::getTranslationalManipulabilityMeasureStrongSense </td>
          <td>(</td>
          <td class="paramtype">const arma::mat &amp;&#160;</td>
          <td class="paramname"><em>jac</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the translational manipulability measure in the strong sense as this is defined in Yoshikawa, Tsuneo. "Translational and rotational
manipulability of robotic manipulators." American Control Conference, 1990. IEEE, 1990. APA. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jac</td><td>The full jacobian matrix of the arm </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The TMM in the strong sense </dd></dl>

</div>
</div>
<a class="anchor" id="a06a0e9d3644bf5720dfc8c5f85a393b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double arl::math::getTranslationalManipulabilityMeasureStrongSense </td>
          <td>(</td>
          <td class="paramtype">const mat &amp;&#160;</td>
          <td class="paramname"><em>jac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mat &amp;&#160;</td>
          <td class="paramname"><em>choose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab4736fd583db4e67f2cbdce900c9404b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double arl::math::getTranslationalManipulabilityMeasureStrongSense </td>
          <td>(</td>
          <td class="paramtype">const arma::mat &amp;&#160;</td>
          <td class="paramname"><em>jac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arma::mat &amp;&#160;</td>
          <td class="paramname"><em>choose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the translational manipulability measure in the strong sense as this is defined in Yoshikawa, Tsuneo. "Translational and rotational
manipulability of robotic manipulators." American Control Conference, 1990. IEEE, 1990. APA. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jac</td><td>The full jacobian matrix of the arm </td></tr>
    <tr><td class="paramname">choose</td><td>A matrix for choosing a specific row of the jacobian (e.g. if you need only the manipulability in the z-axis (3rd row) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The TMM in the strong sense </dd></dl>

</div>
</div>
<a class="anchor" id="af46c677184599a9862485e4f4f654d1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool arl::math::isWithinPolygon </td>
          <td>(</td>
          <td class="paramtype">const arma::vec &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arma::mat &amp;&#160;</td>
          <td class="paramname"><em>polygon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a point lies within a polygon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>The point to check </td></tr>
    <tr><td class="paramname">The</td><td>vertices of the polygon. Should be co-planar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the point lies within the polygon, false otherwise. </dd></dl>
<p>Find the normal vector of the plane of the given points</p>
<p>Find the orthonormal basis of the normal vector</p>
<p>Project the point</p>
<p>Project the polygon points</p>
<p>Find the normal vector of the plane of the given points</p>
<p>Find the orthonormal basis of the normal vector</p>
<p>Project the point</p>
<p>Project the polygon points </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacearl_1_1math_af46c677184599a9862485e4f4f654d1a_cgraph.png" border="0" usemap="#namespacearl_1_1math_af46c677184599a9862485e4f4f654d1a_cgraph" alt=""/></div>
<map name="namespacearl_1_1math_af46c677184599a9862485e4f4f654d1a_cgraph" id="namespacearl_1_1math_af46c677184599a9862485e4f4f654d1a_cgraph">
<area shape="rect" id="node2" href="namespacearl_1_1math.html#a22f589da00ff3faae1fb99cadb90878a" title="Checks if a set of 3D points are cooplannar. " alt="" coords="230,5,381,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aec1eab115040e0a0e335d93e6b865e48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arl::math::pinv_method_ </td>
          <td>(</td>
          <td class="paramtype">pinv_method&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacearl_1_1math_aec1eab115040e0a0e335d93e6b865e48_cgraph.png" border="0" usemap="#namespacearl_1_1math_aec1eab115040e0a0e335d93e6b865e48_cgraph" alt=""/></div>
<map name="namespacearl_1_1math_aec1eab115040e0a0e335d93e6b865e48_cgraph" id="namespacearl_1_1math_aec1eab115040e0a0e335d93e6b865e48_cgraph">
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a94b949c6e7ca3b3c2684425fa670d5a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arl::math::qd_prev_ </td>
          <td>(</td>
          <td class="paramtype">{1, 0, 0, 0}&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a042963eb885eb538bc39572416675617"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arma::mat arl::math::quatToRot </td>
          <td>(</td>
          <td class="paramtype">const arma::vec &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms a quaternion to a rotation matrix. </p>
<p>The quaternion should be given following the convention: w, x, y, z</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The quaternion to be transformed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting rotation matrix </dd></dl>

</div>
</div>
<a class="anchor" id="afe94ac3c6543ab4127acdb0a751d6ca8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arma::vec arl::math::rotateQuat </td>
          <td>(</td>
          <td class="paramtype">const arma::vec &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arma::vec &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integrates the orientation in quaternion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>The angular deviation </td></tr>
    <tr><td class="paramname">q</td><td>The current quaternion in w, x, y, z</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rotated quaternion as described in (24) of "Orientation in
Cartesian Space Dynamic Movement Primitives", Ales Ude1, Bojan Nemec1, Tadej Petric1, and Jun Morimoto. </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacearl_1_1math_afe94ac3c6543ab4127acdb0a751d6ca8_cgraph.png" border="0" usemap="#namespacearl_1_1math_afe94ac3c6543ab4127acdb0a751d6ca8_cgraph" alt=""/></div>
<map name="namespacearl_1_1math_afe94ac3c6543ab4127acdb0a751d6ca8_cgraph" id="namespacearl_1_1math_afe94ac3c6543ab4127acdb0a751d6ca8_cgraph">
<area shape="rect" id="node2" href="namespacearl_1_1math.html#afc4569b9300cd46df7b8573b39c99722" title="Calculates the product of two quaternions. " alt="" coords="198,5,370,32"/><area shape="rect" id="node4" href="namespacearl_1_1math.html#ae5cbf84c1794b164c19e27aa2bb884b3" title="arl::math::getQuatExp" alt="" coords="209,56,359,83"/><area shape="rect" id="node3" href="namespacearl_1_1math.html#a109b0f45c469d8ae2179048a0882a9c3" title="Calculates the skew symmetrix given a 3D vector using KDL. " alt="" coords="419,5,594,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a252cc50703eed077544ff8ac0037249e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool arl::math::rotationHasOrthogonalColumns </td>
          <td>(</td>
          <td class="paramtype">const KDL::Rotation &amp;&#160;</td>
          <td class="paramname"><em>rot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em> = <code>1e-8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests if the columns of the rotation matrix are orthogonal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rot</td><td>The rotation matrix to be tested </td></tr>
    <tr><td class="paramname">eps</td><td>Parameter for the tolerances to rounding errors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the rotation are orthogonal, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a77a59063e37593699cc183c9f8c26df2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool arl::math::rotationHasUnitColumns </td>
          <td>(</td>
          <td class="paramtype">const KDL::Rotation &amp;&#160;</td>
          <td class="paramname"><em>rot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em> = <code>1e-8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests if the columns of the rotation matrix are unit vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rot</td><td>The rotation matrix to be tested </td></tr>
    <tr><td class="paramname">eps</td><td>Parameter for the tolerances to rounding errors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the rotation are unit vectors, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a9d0cfd040f73a0df410290867490c902"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool arl::math::rotationIsOk </td>
          <td>(</td>
          <td class="paramtype">const KDL::Rotation &amp;&#160;</td>
          <td class="paramname"><em>rot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em> = <code>1e-8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests if a 3x3 matrix R is a legit rotation matrix, i.e. if R belongs to SO(3). </p>
<p>This function tests if the columns of the rotation matrix:</p>
<ul>
<li>Are unit vectors</li>
<li>Are orthogonal to each other</li>
<li>Forms a righthanded system</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rot</td><td>The rotation matrix to be tested </td></tr>
    <tr><td class="paramname">eps</td><td>Parameter for the tolerances to rounding errors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the rotation is ok, false otherwise </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacearl_1_1math_a9d0cfd040f73a0df410290867490c902_cgraph.png" border="0" usemap="#namespacearl_1_1math_a9d0cfd040f73a0df410290867490c902_cgraph" alt=""/></div>
<map name="namespacearl_1_1math_a9d0cfd040f73a0df410290867490c902_cgraph" id="namespacearl_1_1math_a9d0cfd040f73a0df410290867490c902_cgraph">
<area shape="rect" id="node2" href="namespacearl_1_1math.html#a77a59063e37593699cc183c9f8c26df2" title="Tests if the columns of the rotation matrix are unit vectors. " alt="" coords="225,5,397,46"/><area shape="rect" id="node3" href="namespacearl_1_1math.html#a252cc50703eed077544ff8ac0037249e" title="Tests if the columns of the rotation matrix are orthogonal. " alt="" coords="205,70,416,111"/><area shape="rect" id="node4" href="namespacearl_1_1math.html#a41abc64cb803f25aadfcf18a721a25a9" title="Tests if the columns of the rotation matrix form a right handed system. " alt="" coords="227,135,394,177"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a41abc64cb803f25aadfcf18a721a25a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool arl::math::rotationIsRightHanded </td>
          <td>(</td>
          <td class="paramtype">const KDL::Rotation &amp;&#160;</td>
          <td class="paramname"><em>rot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em> = <code>1e-8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests if the columns of the rotation matrix form a right handed system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rot</td><td>The rotation matrix to be tested </td></tr>
    <tr><td class="paramname">eps</td><td>Parameter for the tolerances to rounding errors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the rotation is right-handed, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="abb4e0874e1c1504bdcb4e9726ff77ba1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arma::vec arl::math::rotToQuat </td>
          <td>(</td>
          <td class="paramtype">const arma::mat &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms a rotation matrix to a quaternion. </p>
<p>The quaternion will returned following the convention: w, x, y, z</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>A 3x3 armadillo matrix as the rotation matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The quaternion as output </dd></dl>

</div>
</div>
<a class="anchor" id="a83b85c052a9aa6c8e770fe5001ce91b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arma::mat arl::math::rotX </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the basic rotation around the X-axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>The angle for the rotation in rad </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7f4d1be15ff669441d38022971aab717"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arma::mat arl::math::rotY </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the basic rotation around the Y-axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>The angle for the rotation in rad </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af8e642eb6a8a7576d87f7aab5bacd037"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arma::mat arl::math::rotZ </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the basic rotation around the Z-axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>The angle for the rotation in rad </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6f8481a19747b496668529660de78cef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arl::math::singularity_avoid_ </td>
          <td>(</td>
          <td class="paramtype">singularity_avoid&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a109b0f45c469d8ae2179048a0882a9c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void arl::math::skewSymmetric </td>
          <td>(</td>
          <td class="paramtype">const KDL::Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KDL::Rotation *&#160;</td>
          <td class="paramname"><em>skew</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the skew symmetrix given a 3D vector using KDL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A KDL vector </td></tr>
    <tr><td class="paramname">skew</td><td>A KDL rotation matrix as output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac9ffb383ccb1505823894d6d952187f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void arl::math::skewSymmetric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___eigen_plugins.html#gaf4eeda183343d8ca1deabd41e881c31e">Eigen::Matrix</a>&lt; double, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___eigen_plugins.html#gaf4eeda183343d8ca1deabd41e881c31e">Eigen::Matrix</a>&lt; double, 3, 3 &gt; *&#160;</td>
          <td class="paramname"><em>skew</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the skew symmetrix given a 3D vector using Eigen. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>An Eigen 3D vector </td></tr>
    <tr><td class="paramname">skew</td><td>An Eigen 3x3 matrix as output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5efda35e2e9fbcf3edb1b60287a7965e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void arl::math::skewSymmetric </td>
          <td>(</td>
          <td class="paramtype">const arma::vec &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::mat *&#160;</td>
          <td class="paramname"><em>skew</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the skew symmetrix given a 3D vector using Armadillo. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>An arma 3D vector </td></tr>
    <tr><td class="paramname">skew</td><td>An arma 3x3 matrix as output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa2c224d7506d71f09c7c32f87a8df284"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arl::math::sortCircularOrder </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; KDL::Vector &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; KDL::Vector &gt; *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts a set of unsorted points in circular ordering. </p>
<p>This method takes the centroid of the points, calculates the vector of each point to the centroid and sort them by using the minimum angle. This method can not guarantee to work with large point clouds with equal minimum angles occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The set of points to be sorted </td></tr>
    <tr><td class="paramname">output</td><td>The resulted sorted set of points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 25 2018 17:50:08 for AUTh-ARL Core Stack by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
